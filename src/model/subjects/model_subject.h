#ifndef MODEL_SUBJECT_H
#define MODEL_SUBJECT_H

#include "subject.h"

#include "texture.h"
#include "character.h"
#include "node.h"
#include "chapter_node.h"
#include "chapter.h"

#include "relation.h"
#include "relation_types.h"

#include "node_builder.h"
#include "chapter_node_builder.h"
#include "character_builder.h"
#include "chapter_builder.h"

#include <vector>
#include <unordered_map>
#include <memory>


#define TEMP_BACKGROUND_TEXTURE VN_BASE_PATH"/test/assets/test.jpg"
#define TEMP_SPRITE_TEXTURE		VN_BASE_PATH"/test/assets/garu_outline.png"

class ChapterIterator;

// TODO:
// LOAD FILES - modelinfo.format can contain things like what the chapter id for a new game is, textures for home screen etc..
//              chapter#.format can contain the chapter by that id's data
//              node#.format can contain the node by that id's data
//              can separate them into different file structures, reusing ids as folder names.
//              all this to be generated by engine serialization.

/**
 * For creating and owning chapters, characters, base relations, and other objects.
 * The state subject refers to objects created by the model.
 */
class ModelSubject : public Subject {
private:
	static std::unique_ptr<ModelSubject> m_instance;

	static void checkInstance() {
		if (m_instance.get() == nullptr) {
			ModelSubject* model{ new ModelSubject{} };

			m_instance.reset(model);
		}
	}

public:
	using characterMap = std::unordered_map<id, std::unique_ptr<Character>> ;
	

	std::unordered_map<id, std::unique_ptr<ChapterNode>> m_nodes{};
	std::vector<std::unique_ptr<Chapter>>	m_chapters{};
	characterMap m_characters{};
	std::vector<std::unique_ptr<Texture2D>> m_backgrounds{};


	std::list<Chapter*> m_chapterOrder{};

	static Chapter* getChapterById(id chapterId) {
		checkInstance();
		
		ModelSubject* model{ m_instance.get() };
		// TODO: Load from model file if not loaded
	
		// TODO: this is temp for testing
		return model->m_chapters[0].get();
	}

	static Node* getNodeById(id nodeId) {
		checkInstance();

		ModelSubject* model{ m_instance.get() };

		auto iter{ model->m_nodes.find(nodeId) };

		if (iter == model->m_nodes.end()) {
			// TODO: attempt to read the file
			// BUT should already covered by prefetcher on a diff thread,
			// so maybe check a vector containing the nodes currently loading
			std::cout << "NODE NOT FOUND" << std::endl;
			return nullptr;
		}
		else {
			// return a pointer to the node
			return iter->second.get();
		}

	}

	static ChapterIterator iter(int chapterIndex);

	// arr telling which chapters loaded, func to ckeck and load
public:
	static Texture2D* getBackgroundTexture(int index) {
		checkInstance();

		ModelSubject* model = m_instance.get();
		
		return model->m_backgrounds[index].get();
	}

	static const characterMap& getCharacters() {
		checkInstance();

		ModelSubject* model = m_instance.get();

		return model->m_characters;
	}

	static Character* getCharacterByID(int id) {
		checkInstance();

		ModelSubject* model = m_instance.get();

		return model->m_characters[id].get();
	}

private:
	ModelSubject() {}

public:
	~ModelSubject() {}

	static void createChapterOne() {
		checkInstance();

		ModelSubject* model = m_instance.get();

		Chapter* chapterOne = new Chapter{};

		// Can inital all nodes as strays then mark the head node as not a stray with a member variable?
		ChapterNode* head{ new ChapterNode("head node") };

		ChapterNode* oneone{ new ChapterNode("one one node") };
		ChapterNode* onetwo{ new ChapterNode("one two node") };
		
		ChapterNode* twoone{ new ChapterNode("two one node") };
		ChapterNode* twotwo{ new ChapterNode("two two node") };

		ChapterNode* threeone{ new ChapterNode("three one node") };

		ChapterNodeBuilder{ head }.link(oneone);
		ChapterNodeBuilder{ head }.link(onetwo);
		ChapterNodeBuilder{ oneone }.link(twoone);
		ChapterNodeBuilder{ oneone }.link(twotwo);
		ChapterNodeBuilder{ oneone }.link(threeone);
		ChapterNodeBuilder{ twoone }.link(threeone);
		
		ChapterNodeBuilder{ oneone }.unlink(threeone);
		ChapterNodeBuilder{ oneone }.unlink(threeone);

		//chapterOneChild4->addChild(chapterOneChild5);
		// chapterOneHead->addChild(chapterOneHead); TODO: unhandled case yet cycle

		ChapterBuilder{ chapterOne }.setHeadNodeId(head);

		model->m_chapters.push_back(std::unique_ptr<Chapter>(chapterOne));
		model->m_nodes[head->getId()] = std::unique_ptr<ChapterNode>(head);
		model->m_nodes[oneone->getId()] = std::unique_ptr<ChapterNode>(oneone);
		model->m_nodes[onetwo->getId()] = std::unique_ptr<ChapterNode>(onetwo);
		model->m_nodes[twoone->getId()] = std::unique_ptr<ChapterNode>(twoone);
		model->m_nodes[twotwo->getId()] = std::unique_ptr<ChapterNode>(twotwo);
		model->m_nodes[threeone->getId()] = std::unique_ptr<ChapterNode>(threeone);
		//std::cout << chapterOneGraph << std::endl;
	}

	static void initCharacters() {
		checkInstance();

		ModelSubject* model = m_instance.get();
		
		CharacterBuilder garu{};
		garu.setName(L"Garu");
		garu.addTexture(TEMP_SPRITE_TEXTURE);

		CharacterBuilder brz{};
		brz.setName(L"Brazazaza");

		model->m_characters[garu.get()->getId()] = std::unique_ptr<Character>{ garu.get() };
		model->m_characters[brz.get()->getId()] = std::unique_ptr<Character>{ brz.get() };

		initBaseRelations();
	}

	static void initBackgrounds() {
		checkInstance();

		ModelSubject* model = m_instance.get();
		
		std::unique_ptr<Texture2D> background_0{ std::make_unique<Texture2D>(TEMP_BACKGROUND_TEXTURE) };
		model->m_backgrounds.push_back(std::move(background_0));
	}

	static void initRelationTypes() {
		RelationTypes::addRelationType("friendship");
		RelationTypes::addRelationType("respect");
		RelationTypes::addRelationType("hatred");
		RelationTypes::print();
	}

	const std::vector<Relations> m_baseRelations;

	static void initBaseRelations() {
		checkInstance();

		ModelSubject* model = m_instance.get();

		id garuId{ 1 };
		id brzId{ 2 };

		Relations garuRelations{ 1 };
		Relations brzRelations{ 2 };

		int friendshipId = RelationTypes::getRelationId("friendship");
		int respectId = RelationTypes::getRelationId("respect");
		int hatredId = RelationTypes::getRelationId("hatred");

		garuRelations.addCharacterRelation(brzId, friendshipId, 1);
		//std::cout << garuRelations;
		garuRelations.addCharacterRelation(brzId, hatredId, 20);
		//std::cout << garuRelations;
		garuRelations.addCharacterRelation(brzId, hatredId, 2);
		//std::cout << garuRelations;
		garuRelations.addCharacterRelation(brzId, hatredId, -10);
		//std::cout << garuRelations;

		brzRelations.addCharacterRelation(garuId, respectId, 1);

		std::cout << garuRelations;
		std::cout << brzRelations;
	}

	static std::vector<Relations> getBaseRelations() {

	}
};

#endif // MODEL_SUBJECT_H
