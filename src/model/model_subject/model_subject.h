#ifndef MODEL_SUBJECT_H
#define MODEL_SUBJECT_H

#include "subject.h"

#include "index.h"
#include "texture.h"
#include "character.h"
#include "node.h"
#include "chapter_node.h"
#include "chapter.h"
#include "texture_store.h"

#include "relations.h"
#include "relation_types.h"

#include "model_chapters.h"
#include "model_textures.h"
#include "model_relations.h"

#include "node_builder.h"
#include "chapter_node_builder.h"
#include "character_builder.h"
#include "chapter_builder.h"
#include "relations_builder.h"
#include "texture_store_builder.h"

#include <vector>
#include <unordered_map>
#include <memory>

class ChapterIterator;

// TODO:
// LOAD FILES - modelinfo.format can contain things like what the chapter id for a new game is, textures for home screen etc..
//              chapter#.format can contain the chapter by that id's data
//              node#.format can contain the node by that id's data
//              can separate them into different file structures, reusing ids as folder names.
//              all this to be generated by engine serialization.

/**
 * For creating and owning chapters, characters, base relations, and other objects.
 * The state subject refers to objects created by the model.
 */
class ModelSubject : public Subject {
private:
	static std::unique_ptr<ModelSubject> m_instance;

	static ModelSubject* checkInstance() {
		if (m_instance.get() == nullptr) {
			ModelSubject* model{ new ModelSubject{} };

			m_instance.reset(model);
		}

		return m_instance.get();
	}

	ModelChapters m_modelChapters{};
	ModelTextures m_modelTextures{};
	ModelRelations m_modelRelations{};

public:
	using CharacterMap = std::unordered_map<id, std::unique_ptr<Character>>;
	CharacterMap m_characters{};

	static void init() {
		ModelSubject* model = checkInstance();

		model->m_modelChapters.createChapterOne();
		model->m_modelTextures.initTextureStores();
		model->m_modelRelations.initRelationTypes();
		model->m_modelRelations.initBaseRelations();
	}

	static Chapter* getChapterById(id chapterId) {
		ModelSubject* model = checkInstance();

		return model->m_modelChapters.getChapterById(chapterId);
	}

	static Node* getNodeById(id nodeId) {
		ModelSubject* model = checkInstance();

		return model->m_modelChapters.getNodeById(nodeId);
	}

	static ChapterIterator iter(int chapterIndex);

	// arr telling which chapters loaded, func to ckeck and load
public:
	static const CharacterMap& getCharacters() {
		ModelSubject* model = checkInstance();

		return model->m_characters;
	}

	static Character* getCharacterByID(int id) {
		ModelSubject* model = checkInstance();

		return model->m_characters[id].get();
	}

private:
	ModelSubject() {}

public:
	~ModelSubject() {}

	

	static void initCharacters() {
		ModelSubject* model = checkInstance();
		
		Character* garu = new Character();
		CharacterBuilder{ garu }.setName(L"Garu");

		CharacterBuilder brz{};
		brz.setName(L"Brazazaza");

		model->m_characters[garu->getId()] = std::unique_ptr<Character>{ garu };
		model->m_characters[brz.get()->getId()] = std::unique_ptr<Character>{ brz.get() };
	}

	static void loadTexture(TextureIdentifier& textureId) {
		ModelSubject* model = checkInstance();

		model->m_modelTextures.loadTexture(textureId);
	}

	static const std::unordered_map<id, std::unique_ptr<Relations>>& getBaseRelations() {
		ModelSubject* model = checkInstance();

		return model->m_modelRelations.m_baseRelations;
	}
};

#endif // MODEL_SUBJECT_H
