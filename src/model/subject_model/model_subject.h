#ifndef MODEL_SUBJECT_H
#define MODEL_SUBJECT_H

#include "subject.h"

#include "timer.h"
#include "index.h"
#include "texture.h"
#include "character.h"
#include "node.h"
#include "chapter_node.h"
#include "chapter.h"
#include "texture_store.h"

#include "relations.h"
#include "relation_types.h"

#include "model_chapters.h"
#include "model_textures.h"
#include "model_relations.h"
#include "model_characters.h"

#include "engine_chapter_manager.h"

#include "chapter_node_builder.h"
#include "character_builder.h"
#include "chapter_builder.h"
#include "relations_builder.h"
#include "texture_store_builder.h"

#include <vector>
#include <unordered_map>
#include <memory>
#include <thread>

class ChapterIterator;
class ModelRuntimeInterface;
class ModelEngineInterface;

// TODO:
// LOAD FILES - modelinfo.format can contain things like what the chapter id for a new game is, textures for home screen etc..
//              chapter#.format can contain the chapter by that id's data
//              node#.format can contain the node by that id's data
//              can separate them into different file structures, reusing ids as folder names.
//              all this to be generated by engine serialization.

/**
 * For creating and owning chapters, characters, base relations, and other objects.
 * The state subject refers to objects created by the model.
 */

// TODO: arr telling which chapters loaded, func to ckeck and load
class ModelSubject : public Subject {
private:
	// Interface friend classes
	friend class ModelRuntimeInterface;
	friend class ModelEngineInterface;

	// Singleton helpers
	static std::unique_ptr<ModelSubject> m_instance;

	static ModelSubject* validateInstance() {
		if (m_instance.get() == nullptr) {
			ModelSubject* model{ new ModelSubject{} };

			m_instance.reset(model);
		}

		return m_instance.get();
	}

private:
	// Singleton state
	ModelSubject() {}

	ModelChapters m_modelChapters{};
	ModelTextures m_modelTextures{};
	ModelRelations m_modelRelations{};
	ModelCharacters m_modelCharacters{};

public:
	~ModelSubject() { std::cout << "MODEL DECONSTRUCTOR CALLED" << std::endl; }

	static void init() {
		ModelSubject* model{ validateInstance() };
		// TODO: class variable to void multiple inits

		Timer timer{};

		timer.resetp();
		/*
		// Without multithreading

		model->m_modelChapters.createChapterOne();
		model->m_modelTextures.initTextureStores();
		//model->m_modelRelations.initRelationTypes();
		model->m_modelRelations.initBaseRelations();
		model->m_modelCharacters.initCharacters();
		*/

		// With multithreading
		std::thread chaptersThread(&ModelChapters::createChapterOne, &model->m_modelChapters);
		std::thread relationsThread(&ModelRelations::initBaseRelations, &model->m_modelRelations);
		std::thread charactersThread(&ModelCharacters::initCharacters, &model->m_modelCharacters);
		std::thread texturesThread(&ModelTextures::initTextureStores, &model->m_modelTextures);

		// Wait for the threads to finish
		chaptersThread.join();
		relationsThread.join();
		charactersThread.join();
		texturesThread.join();
		 
		timer.elapsedp();
	}

	// TODO: make the functions below private, only for use through interface objects.

	// Iterators
	static ChapterIterator iter();
	static ChapterIterator iter(id chapterId);

	// Chapters and nodes
	static id getFirstChapterId() {
		return 1;
	}

	static const Chapter* getHeadChapter() {
		ModelSubject* model{ validateInstance() };
		
		return model->m_modelChapters.getHeadChapter();
	}

	static Chapter* getChapterById(id chapterId) {
		ModelSubject* model{ validateInstance() };

		return model->m_modelChapters.getChapterById(chapterId);
	}

	static Node* getNodeById(id nodeId) {
		ModelSubject* model{ validateInstance() };

		return model->m_modelChapters.getNodeById(nodeId);
	}
};

#endif // MODEL_SUBJECT_H
